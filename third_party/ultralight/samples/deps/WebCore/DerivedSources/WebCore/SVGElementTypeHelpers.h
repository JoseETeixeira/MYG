/*
 * THIS FILE WAS AUTOMATICALLY GENERATED, DO NOT EDIT.
 *
 * This file was generated by the dom/make_names.pl script.
 *
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2013 Apple Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SVGElementTypeHelpers_h
#define SVGElementTypeHelpers_h

#include "SVGNames.h"

namespace WebCore {
class SVGAElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGAElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::aTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::aTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGAltGlyphDefElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGAltGlyphDefElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::altGlyphDefTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::altGlyphDefTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGAltGlyphElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGAltGlyphElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::altGlyphTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::altGlyphTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGAltGlyphItemElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGAltGlyphItemElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::altGlyphItemTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::altGlyphItemTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGAnimateColorElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGAnimateColorElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::animateColorTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::animateColorTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGAnimateElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGAnimateElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::animateTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::animateTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGAnimateMotionElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGAnimateMotionElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::animateMotionTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::animateMotionTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGAnimateTransformElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGAnimateTransformElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::animateTransformTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::animateTransformTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGCircleElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGCircleElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::circleTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::circleTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGClipPathElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGClipPathElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::clipPathTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::clipPathTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGCursorElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGCursorElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::cursorTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::cursorTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGDefsElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGDefsElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::defsTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::defsTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGDescElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGDescElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::descTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::descTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGEllipseElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGEllipseElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::ellipseTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::ellipseTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEBlendElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEBlendElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feBlendTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feBlendTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEColorMatrixElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEColorMatrixElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feColorMatrixTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feColorMatrixTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEComponentTransferElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEComponentTransferElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feComponentTransferTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feComponentTransferTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFECompositeElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFECompositeElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feCompositeTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feCompositeTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEConvolveMatrixElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEConvolveMatrixElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feConvolveMatrixTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feConvolveMatrixTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEDiffuseLightingElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEDiffuseLightingElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feDiffuseLightingTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feDiffuseLightingTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEDisplacementMapElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEDisplacementMapElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feDisplacementMapTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feDisplacementMapTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEDistantLightElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEDistantLightElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feDistantLightTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feDistantLightTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEDropShadowElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEDropShadowElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feDropShadowTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feDropShadowTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEFloodElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEFloodElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feFloodTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feFloodTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEFuncAElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEFuncAElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feFuncATag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feFuncATag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEFuncBElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEFuncBElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feFuncBTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feFuncBTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEFuncGElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEFuncGElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feFuncGTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feFuncGTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEFuncRElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEFuncRElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feFuncRTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feFuncRTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEGaussianBlurElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEGaussianBlurElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feGaussianBlurTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feGaussianBlurTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEImageElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEImageElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feImageTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feImageTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEMergeElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEMergeElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feMergeTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feMergeTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEMergeNodeElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEMergeNodeElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feMergeNodeTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feMergeNodeTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEMorphologyElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEMorphologyElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feMorphologyTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feMorphologyTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEOffsetElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEOffsetElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feOffsetTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feOffsetTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFEPointLightElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFEPointLightElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::fePointLightTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::fePointLightTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFESpecularLightingElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFESpecularLightingElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feSpecularLightingTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feSpecularLightingTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFESpotLightElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFESpotLightElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feSpotLightTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feSpotLightTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFETileElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFETileElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feTileTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feTileTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFETurbulenceElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFETurbulenceElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::feTurbulenceTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::feTurbulenceTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFilterElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFilterElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::filterTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::filterTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFontElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFontElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::fontTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::fontTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFontFaceElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFontFaceElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::font_faceTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::font_faceTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFontFaceFormatElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFontFaceFormatElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::font_face_formatTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::font_face_formatTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFontFaceNameElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFontFaceNameElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::font_face_nameTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::font_face_nameTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFontFaceSrcElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFontFaceSrcElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::font_face_srcTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::font_face_srcTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGFontFaceUriElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGFontFaceUriElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::font_face_uriTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::font_face_uriTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGForeignObjectElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGForeignObjectElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::foreignObjectTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::foreignObjectTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGGElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGGElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::gTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::gTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGGlyphElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGGlyphElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::glyphTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::glyphTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGGlyphRefElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGGlyphRefElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::glyphRefTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::glyphRefTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGHKernElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGHKernElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::hkernTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::hkernTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGImageElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGImageElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::imageTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::imageTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGLineElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGLineElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::lineTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::lineTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGLinearGradientElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGLinearGradientElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::linearGradientTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::linearGradientTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGMPathElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGMPathElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::mpathTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::mpathTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGMarkerElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGMarkerElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::markerTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::markerTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGMaskElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGMaskElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::maskTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::maskTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGMetadataElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGMetadataElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::metadataTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::metadataTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGMissingGlyphElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGMissingGlyphElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::missing_glyphTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::missing_glyphTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGPathElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGPathElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::pathTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::pathTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGPatternElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGPatternElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::patternTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::patternTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGPolygonElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGPolygonElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::polygonTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::polygonTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGPolylineElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGPolylineElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::polylineTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::polylineTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGRadialGradientElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGRadialGradientElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::radialGradientTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::radialGradientTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGRectElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGRectElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::rectTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::rectTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGSVGElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGSVGElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::svgTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::svgTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGScriptElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGScriptElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::scriptTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::scriptTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGSetElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGSetElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::setTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::setTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGStopElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGStopElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::stopTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::stopTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGStyleElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGStyleElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::styleTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::styleTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGSwitchElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGSwitchElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::switchTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::switchTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGSymbolElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGSymbolElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::symbolTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::symbolTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGTRefElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGTRefElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::trefTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::trefTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGTSpanElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGTSpanElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::tspanTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::tspanTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGTextElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGTextElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::textTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::textTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGTextPathElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGTextPathElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::textPathTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::textPathTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGTitleElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGTitleElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::titleTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::titleTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGUseElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGUseElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::useTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::useTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGVKernElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGVKernElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::vkernTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::vkernTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

namespace WebCore {
class SVGViewElement;
}
namespace WTF {
template<typename ArgType> class TypeCastTraits<const WebCore::SVGViewElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::SVGElement& element) { return element.hasTagName(WebCore::SVGNames::viewTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::SVGNames::viewTag); }
    static bool checkTagName(const WebCore::EventTarget& target) { return is<WebCore::Node>(target) && checkTagName(downcast<WebCore::Node>(target)); }
};
}

#endif
